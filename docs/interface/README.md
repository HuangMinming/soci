# Interface function description

## Paillier
| Function Name GMP| Description | Input | Output |
| ------ | ------ | ------ | ------ |
| keygen(unsigned long $\kappa$) | generate a PaillierTD public/private key pair $(pk, sk)$ | $\kappa$ – the intense of key | NULL |
| encrypt(mpz_t $c$, mpz_t $m$) | encpyt message $m$ to $c$ using public key $pk$ | $m$ – a plaintext, which is mpz_t type. mpz_t  is a GMP data type which is a multiple precision integer(same below). | $c$ – encrypted result, is a ciphertext and mpz_t type. |
| decrypt(mpz_t $m$, mpz_t $c$) | decpyt ciphertext $c$ to plaintext $m$ using private key $sk$ | $c$ – a ciphertext, which is mpz_t type. | $m$ – decrypted result, is a plaintext and mpz_t type. |
| add(mpz_t $res$, mpz_t $c_1$, mpz_t $c_2$)  | additive homomorphism operation |$c_1$ –augend, is a ciphertext and mpz_t type, which should between 0 and $N^2$. <br>$c_2$ –another augend, is a ciphertext and mpz_t type, which should between 0 and $N^2$  | $res$ – the result of additive homomorphism of $c_1$ and $c_2$, is a ciphertext, also mpz_t type.|
| scl_mul(mpz_t $res$, mpz_t $c$, mpz_t $e$) | scalar-multiplication homomorphism operation | $c$ – is a ciphertext and mpz_t type, which should between 0 and $N^2$.<br>e – is a plaintext and mpz_t type, which should between 0 and $N^2$.| $res$ – the result of scalar-multiplication homomorphism of $c$ and $e$, is a ciphertext, also mpz_t type. |

## ThirdKeyGen
| Function Name | Description | Input | Output |
| ------ | ------ | ------ | ------ |
| thdkeygen(Paillier pai, int sigma, PaillierThd * $cp$, PaillierThd * $csp$) | splits $sk$ into two partially private keys $(sk_1, sk_2)$, while $sk$ is the private key of pai. distributes $(pk, sk_1)$ and $(pk, sk_2)$ to CP and CSP, respectively | pai – is a Paillier which generate private key and public key.<br>sigma – to generate a random number with sigma bits.<br>$cp$ – stores $(pk, sk_1)$. <br>$csp$ – stores $(pk, sk_2)$. | NULL |

 ## PaillierThd
| Function Name | Description | Input | Output |
| ------ | ------ | ------ | ------ |
| pdec(mpz_t $pc$, mpz_t $c$) | Partial Decryption, using $sk_1$ or $sk_2$ which is generated by thdkeygen | $c$ – is a ciphertext and mpz_t type. | $pc$ – the result of partial decryption, is a ciphertext and mpz_t type. |
| fdec(mpz_t $m$, mpz_t $c_1$, mpz_t $c_2$) | Threshold Decryption, using $sk_1$ or $sk_2$ which is generated by thdkeygen | $c_1$ – partially decrypted ciphtext which is output of fdec using $sk_1$.<br>$c_2$ – partially decrypted ciphtext which is output of fdec using $sk_2$ | $m$ – the result of partial decryption, is a plaintext and mpz_t type. |

 ## seccomp
| Function Name | Description | Input | Output |
| ------ | ------ | ------ | ------ |
| smul(mpz_t $res$, mpz_t $ex$, mpz_t $ey$, PaillierThd $cp$, PaillierThd $csp$) | Secure Multiplication operation | $ex$ – is a ciphertext and mpz_t type.<br>$ey$ – is a ciphertext and mpz_t type.<br>$cp$ – is a PaillierThd which owns $sk_1$.<br>$csp$ – is a PaillierThd which owns $sk_2$. | $res$ – the result of Secure Multiplication, is a ciphertext and mpz_t type. |
 | scmp(mpz_t $res$, mpz_t $ex$, mpz_t $ey$, PaillierThd $cp$, PaillierThd $csp$) | compare $ex$ and $ey$, which are encrypted from plaintext $x$ and $y$, separately, when $x \geq y$, $res$ is 0, otherwise, $res$ is 1.  | ex – a ciphertext which is encrypted from plaintext $x$.<br>$ey$ – a ciphertext which is encrypted from plaintext $y$.<br>$cp$ – is a PaillierThd which owns $sk_1$.<br>$csp$ – is a PaillierThd which owns $sk_2$. | $res$ – the result of secure comparison, is a ciphertext. |
 | ssba(mpz_t $s_x$, mpz_t $u_x$, mpz_t $ex$, PaillierThd $cp$, PaillierThd $csp$) | given a ciphertext $ex$ which is encrypted from plaintext $x$, get the secure sign bit-acquisition result $s_x$ and $u_x$.  | $ex$ – a ciphertext which is encrypted from plaintext $x$.<br>$cp$ – is a PaillierThd which owns $sk_1$.<br>$csp$ – is a PaillierThd which owns $sk_2$. | $s_x$ – the sign bit of $x$,if $x\geq 0$=0, it is 0, otherwise 1, in ciphertext.<br>$u_x=[-x]$ if $x<0$, and $u_x=[x]$ if $x\geq 0$, in ciphertext. |
 | sdiv(mpz_t $eq$, mpz_t $er$, mpz_t $ex$, mpz_t $ey$, int $ell$, PaillierThd $cp$, PaillierThd $csp$, Paillier $pai$) | given two ciphertextx $ex$ and $ey$, which are encrypted from plaintext $x$ and $y$, respectively,  compute the quotient and the remainder of $x$ divided by $y$.  | $ex$ – a ciphertext which is encrypted from plaintext $x$. <br>$ey$ – a ciphertext which is encrypted from plaintext $y$. <br>$el$ – is a constant (e.g., $l$ = 32) and is used to control the domain size of plaintext. In practice, we can change $l$ to support larger integers. <br>$cp$ – is a PaillierThd which owns $sk_1$. <br>$csp$ – is a PaillierThd which owns $sk_2$.  | $eq$ – the quotient of $x$ divided by $y$, in ciphertext. <br>$er$ – the remainder of $x$ divided by $y$, in ciphertext. |
 
